import { Node, Symbol, SyntaxKind } from "typescript";

/**
 * 
 * @param node Node Tree to walk thru
 */
export function * ThruWalker(node: Node): Generator<Node, void>{
    // Yield self the first
    yield node;
    // Loop Child
    for(const child of node.getChildren()){
        yield * ThruWalker(child);
    }
}

/**
 * @param symbol check if the symbol is defined by declaration
 */
export function isFromDeclarationFile(symbol: Symbol){
    // If file is not present at all then its probably something autogenerated,
    // so le'ts return true (as declaration) 
    return symbol.valueDeclaration?.getSourceFile()?.isDeclarationFile??true;
}

type OnlyNumber<T> = T extends Number ? T : never;

// Walk thru the TS AST Tree
export function traverse<T extends OnlyNumber<SyntaxKind>>(node: Node, handler: {[key in T]: (node: Node)=>boolean}){
    visit(node, (node)=>handler[node.kind as T]?.(node));
}
/**
 * 
 * @param node Node
 * @param caller Skips when true
 */
export function visit(node: Node, caller: (node: Node)=>(boolean | Node)): Node | null{
    const data = caller(node);
    if(data === true || data === node) return null;
    if(data) return data;
    for(const n of node.getChildren()){
        const upper = visit(n, caller);
        if(upper && upper != node) return upper;
    }
    return null;
}

/**
 * 
 * @param node Node
 * @param caller Skips when true
 */
export function * visiter(node: Node): Generator<Node, Node | null, boolean | Node | null>{
    const data = yield node;
    if(data === true || data === node) return null;
    if(data) return data;
    for(const n of node.getChildren()){
        const upper = yield * visiter(n);
        if(upper && upper !== node) return upper;
    }
    return null;
}